<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Examples &#8212; OVITO 2.9.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/rtd.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.9.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/ovito.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="OVITO 2.9.0 documentation" href="../index.html" />
    <link rel="next" title="ovito" href="../modules/ovito.html" />
    <link rel="prev" title="Writing new modifiers" href="custom_modifiers.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../modules/ovito.html" title="ovito"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="custom_modifiers.html" title="Writing new modifiers"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">OVITO 2.9.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h1>
<p>This page provides a collection of example scripts:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#example-compute-voronoi-indices"><span class="std std-ref">Computing Voronoi indices</span></a></li>
<li><a class="reference internal" href="#example-compute-cna-bond-indices"><span class="std std-ref">Computing CNA bond indices</span></a></li>
<li><a class="reference internal" href="#example-msd-calculation"><span class="std std-ref">Writing a custom modifier for calculating the mean square displacement</span></a></li>
<li><a class="reference internal" href="#example-order-parameter-calculation"><span class="std std-ref">Implementing an advanced analysis modifier</span></a></li>
<li><a class="reference internal" href="#example-creating-particles-programmatically"><span class="std std-ref">Creating particles and bonds programmatically</span></a></li>
<li><a class="reference internal" href="#example-visualize-local-lattice-orientation"><span class="std std-ref">Visualizing local lattice orientations using particle coloring</span></a></li>
</ul>
</div></blockquote>
<div class="section" id="computing-voronoi-indices">
<span id="example-compute-voronoi-indices"></span><h2>Computing Voronoi indices<a class="headerlink" href="#computing-voronoi-indices" title="Permalink to this headline">¶</a></h2>
<p>This script demonstrates the use of the Voronoi analysis modifier.
The script calculates the distribution of Voronoi coordination polyhedra in an amorphous structure.</p>
<p>A Voronoi polyhedron is expressed in terms of the Schlaefli notation,
which is a vector of indices (n<sub>1</sub>, n<sub>2</sub>, n<sub>3</sub>, n<sub>4</sub>, n<sub>5</sub>, n<sub>6</sub>, ...),
where n<sub>i</sub> is the number of polyhedron faces with <em>i</em> edges/vertices.</p>
<p>The script computes the distribution of these Voronoi index vectors
and lists the 10 most frequent polyhedron types in the dataset. In the case
of a Cu<sub>64%</sub>-Zr<sub>36%</sub> bulk metallic glass, the most frequent polyhedron type is the icosahedron.
It has 12 faces with five edges each. Thus, the corresponding Voronoi index
vector is:</p>
<blockquote>
<div>(0, 0, 0, 0, 12, 0, ...)</div></blockquote>
<p>Python script:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Import OVITO modules.</span>
<span class="kn">from</span> <span class="nn">ovito.io</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">ovito.modifiers</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1"># Import NumPy module.</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c1"># Load a simulation snapshot of a Cu-Zr metallic glass.</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;../data/CuZr_metallic_glass.dump.gz&quot;</span><span class="p">)</span>

<span class="c1"># Set atomic radii (required for polydisperse Voronoi tessellation).</span>
<span class="n">atypes</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">particle_properties</span><span class="o">.</span><span class="n">particle_type</span><span class="o">.</span><span class="n">type_list</span>
<span class="n">atypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">1.35</span>        <span class="c1"># Cu atomic radius (atom type 1 in input file)</span>
<span class="n">atypes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mf">1.55</span>        <span class="c1"># Zr atomic radius (atom type 2 in input file)</span>

<span class="c1"># Set up the Voronoi analysis modifier.</span>
<span class="n">voro</span> <span class="o">=</span> <span class="n">VoronoiAnalysisModifier</span><span class="p">(</span>
    <span class="n">compute_indices</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">use_radii</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">edge_count</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="c1"># Length after which Voronoi index vectors are truncated</span>
    <span class="n">edge_threshold</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="p">)</span>
<span class="n">node</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">voro</span><span class="p">)</span>
                      
<span class="c1"># Let OVITO compute the results.</span>
<span class="n">node</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

<span class="c1"># Make sure we did not lose information due to truncated Voronoi index vectors.</span>
<span class="k">if</span> <span class="n">voro</span><span class="o">.</span><span class="n">max_face_order</span> <span class="o">&gt;</span> <span class="n">voro</span><span class="o">.</span><span class="n">edge_count</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: Maximum face order in Voronoi tessellation is </span><span class="si">{0}</span><span class="s2">, &quot;</span>
          <span class="s2">&quot;but computed Voronoi indices are truncated after </span><span class="si">{1}</span><span class="s2"> entries. &quot;</span>
          <span class="s2">&quot;You should consider increasing the &#39;edge_count&#39; parameter to </span><span class="si">{0}</span><span class="s2">.&quot;</span>
          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">voro</span><span class="o">.</span><span class="n">max_face_order</span><span class="p">,</span> <span class="n">voro</span><span class="o">.</span><span class="n">edge_count</span><span class="p">))</span>
    <span class="c1"># Note that it would be possible to automatically increase the &#39;edge_count&#39;</span>
    <span class="c1"># parameter to &#39;max_face_order&#39; here and recompute the Voronoi tessellation:</span>
    <span class="c1">#   voro.edge_count = voro.max_face_order</span>
    <span class="c1">#   node.compute()</span>

<span class="c1"># Access computed Voronoi indices as NumPy array.</span>
<span class="c1"># This is an (N)x(edge_count) array.</span>
<span class="n">voro_indices</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">particle_properties</span><span class="p">[</span><span class="s1">&#39;Voronoi Index&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">array</span>

<span class="c1"># This helper function takes a two-dimensional array and computes a frequency </span>
<span class="c1"># histogram of the data rows using some NumPy magic. </span>
<span class="c1"># It returns two arrays (of equal length): </span>
<span class="c1">#    1. The list of unique data rows from the input array</span>
<span class="c1">#    2. The number of occurences of each unique row</span>
<span class="c1"># Both arrays are sorted in descending order such that the most frequent rows </span>
<span class="c1"># are listed first.</span>
<span class="k">def</span> <span class="nf">row_histogram</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">ca</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">([(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">unique</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">inverse</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">inverse</span><span class="p">)</span>
    <span class="n">sort_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">counts</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">sort_indices</span><span class="p">]],</span> <span class="n">counts</span><span class="p">[</span><span class="n">sort_indices</span><span class="p">])</span>

<span class="c1"># Compute frequency histogram.</span>
<span class="n">unique_indices</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">row_histogram</span><span class="p">(</span><span class="n">voro_indices</span><span class="p">)</span>

<span class="c1"># Print the ten most frequent histogram entries.</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%i</span><span class="se">\t</span><span class="s2">(</span><span class="si">%.1f</span><span class="s2"> </span><span class="si">%%</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">unique_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> 
                                 <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> 
                                 <span class="mf">100.0</span><span class="o">*</span><span class="nb">float</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">voro_indices</span><span class="p">)))</span>
</pre></div>
</div>
<p>Program output:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>(0, 0, 0, 0, 12, 0)     12274   (11.4 %)
(0, 0, 0, 2, 8, 2)      7485    (6.9 %)
(0, 0, 0, 3, 6, 4)      5637    (5.2 %)
(0, 0, 0, 1, 10, 2)     4857    (4.5 %)
(0, 0, 0, 3, 6, 3)      3415    (3.2 %)
(0, 0, 0, 2, 8, 1)      2927    (2.7 %)
(0, 0, 0, 1, 10, 5)     2900    (2.7 %)
(0, 0, 0, 1, 10, 4)     2068    (1.9 %)
(0, 0, 0, 2, 8, 6)      2063    (1.9 %)
(0, 0, 0, 2, 8, 5)      1662    (1.5 %)
</pre></div>
</div>
</div>
<div class="section" id="computing-cna-bond-indices">
<span id="example-compute-cna-bond-indices"></span><h2>Computing CNA bond indices<a class="headerlink" href="#computing-cna-bond-indices" title="Permalink to this headline">¶</a></h2>
<p>The following script demonstrates how to use the <a class="reference internal" href="../modules/ovito_modifiers.html#ovito.modifiers.CreateBondsModifier" title="ovito.modifiers.CreateBondsModifier"><code class="xref py py-class docutils literal"><span class="pre">CreateBondsModifier</span></code></a>
to create bonds between particles. The structural environment of each created bond
is then characterized with the help of the <a class="reference internal" href="../modules/ovito_modifiers.html#ovito.modifiers.CommonNeighborAnalysisModifier" title="ovito.modifiers.CommonNeighborAnalysisModifier"><code class="xref py py-class docutils literal"><span class="pre">CommonNeighborAnalysisModifier</span></code></a>,
which computes a triplet of indices for each bond from the topology of the surrounding bond network.
The script accesses the computed CNA bond indices in the output <a class="reference internal" href="../modules/ovito_data.html#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal"><span class="pre">DataCollection</span></code></a> of the
modification pipeline and exports them to a text file. The script enumerates the bonds of each particle
using the <a class="reference internal" href="../modules/ovito_data.html#ovito.data.Bonds.Enumerator" title="ovito.data.Bonds.Enumerator"><code class="xref py py-class docutils literal"><span class="pre">Bonds.Enumerator</span></code></a> helper class.</p>
<p>The generated text file has the following format:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Atom</span>    <span class="n">CNA_pair_type</span><span class="p">:</span><span class="n">Number_of_such_pairs</span> <span class="o">...</span>

<span class="mi">1</span>       <span class="p">[</span><span class="mi">4</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">]:</span><span class="mi">2</span>  <span class="p">[</span><span class="mi">4</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">]:</span><span class="mi">1</span> <span class="p">[</span><span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span><span class="p">]:</span><span class="mi">1</span>
<span class="mi">2</span>       <span class="o">...</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Python script:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Import OVITO modules.</span>
<span class="kn">from</span> <span class="nn">ovito.io</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">ovito.modifiers</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">ovito.data</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1"># Import standard Python and NumPy modules.</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c1"># Load the simulation dataset to be analyzed.</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;../data/NanocrystallinePd.dump.gz&quot;</span><span class="p">)</span>

<span class="c1"># Create bonds.</span>
<span class="n">node</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CreateBondsModifier</span><span class="p">(</span><span class="n">cutoff</span> <span class="o">=</span> <span class="mf">3.5</span><span class="p">))</span>

<span class="c1"># Compute CNA indices on the basis of the created bonds.</span>
<span class="n">node</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">CommonNeighborAnalysisModifier</span><span class="p">(</span><span class="n">mode</span> <span class="o">=</span> <span class="n">CommonNeighborAnalysisModifier</span><span class="o">.</span><span class="n">Mode</span><span class="o">.</span><span class="n">BondBased</span><span class="p">))</span>
                      
<span class="c1"># Let OVITO&#39;s data pipeline do the heavy work.</span>
<span class="n">node</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>

<span class="c1"># A two-dimensional array containing the three CNA indices </span>
<span class="c1"># computed for each bond in the system.</span>
<span class="n">cna_indices</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">bond_properties</span><span class="p">[</span><span class="s1">&#39;CNA Indices&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">array</span>

<span class="c1"># This helper function takes a two-dimensional array and computes the frequency </span>
<span class="c1"># histogram of the data rows using some NumPy magic. </span>
<span class="c1"># It returns two arrays (of same length): </span>
<span class="c1">#    1. The list of unique data rows from the input array</span>
<span class="c1">#    2. The number of occurences of each unique row</span>
<span class="k">def</span> <span class="nf">row_histogram</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">ca</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">([(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)]</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">unique</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">inverse</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">inverse</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">counts</span><span class="p">)</span>

<span class="c1"># Used below for enumerating the bonds of each particle:</span>
<span class="n">bond_enumerator</span> <span class="o">=</span> <span class="n">Bonds</span><span class="o">.</span><span class="n">Enumerator</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span>

<span class="c1"># Loop over particles and print their CNA indices.</span>
<span class="k">for</span> <span class="n">particle_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">number_of_particles</span><span class="p">):</span>
    
    <span class="c1"># Print particle index (1-based).</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%i</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">particle_index</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="c1"># Create local list with CNA indices of the bonds of the current particle.</span>
    <span class="n">bond_index_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bond_enumerator</span><span class="o">.</span><span class="n">bonds_of_particle</span><span class="p">(</span><span class="n">particle_index</span><span class="p">))</span>
    <span class="n">local_cna_indices</span> <span class="o">=</span> <span class="n">cna_indices</span><span class="p">[</span><span class="n">bond_index_list</span><span class="p">]</span>

    <span class="c1"># Count how often each type of CNA triplet occurred.</span>
    <span class="n">unique_triplets</span><span class="p">,</span> <span class="n">triplet_counts</span> <span class="o">=</span> <span class="n">row_histogram</span><span class="p">(</span><span class="n">local_cna_indices</span><span class="p">)</span>
    
    <span class="c1"># Print list of triplets with their respective counts.</span>
    <span class="k">for</span> <span class="n">triplet</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unique_triplets</span><span class="p">,</span> <span class="n">triplet_counts</span><span class="p">):</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">:</span><span class="si">%i</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">triplet</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
    
    <span class="c1"># End of particle line</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="writing-a-custom-modifier-for-calculating-the-mean-square-displacement">
<span id="example-msd-calculation"></span><h2>Writing a custom modifier for calculating the mean square displacement<a class="headerlink" href="#writing-a-custom-modifier-for-calculating-the-mean-square-displacement" title="Permalink to this headline">¶</a></h2>
<p>OVITO allows you to implement your <a class="reference internal" href="custom_modifiers.html#writing-custom-modifiers"><span class="std std-ref">own type of analysis modifier</span></a> by writing a Python function that gets called every time
the data pipeline is evaluated. This user-defined function has access to the positions and other properties of particles
and can output information and results as new properties or global attributes.</p>
<p>As a first simple example, we look at the calculation of the mean square displacement (MSD) in a system of moving particles.
OVITO already provides the built-in <a class="reference external" href="../../particles.modifiers.displacement_vectors.html">Displacement Vectors</a> modifier, which
calculates the displacement of every particle. It stores its results in the <code class="docutils literal"><span class="pre">&quot;Displacement</span> <span class="pre">Magnitude&quot;</span></code>
particle property. So all our custom analysis modifier needs to do is to sum up the squared displacement magnitudes and divide by the number of particles:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>

    <span class="c1"># Access the per-particle displacement magnitudes computed by an existing </span>
    <span class="c1"># Displacement Vectors modifier that precedes this custom modifier in the </span>
    <span class="c1"># data pipeline:</span>
    <span class="n">displacement_magnitudes</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">particle_properties</span><span class="o">.</span><span class="n">displacement_magnitude</span><span class="o">.</span><span class="n">array</span>

    <span class="c1"># Compute MSD:</span>
    <span class="n">msd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">displacement_magnitudes</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">displacement_magnitudes</span><span class="p">)</span>

    <span class="c1"># Output MSD value as a global attribute: </span>
    <span class="n">output</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;MSD&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">msd</span> 
</pre></div>
</div>
<p>When used within the graphical program, the MSD value computed by this custom modifier may be exported to a text file as a function of simulation time using
OVITO&#8217;s standard file export feature (Select <code class="docutils literal"><span class="pre">Calculation</span> <span class="pre">Results</span> <span class="pre">Text</span> <span class="pre">File</span></code> as output format).</p>
<p>Alternatively, we can make use of the custom modifier from within a non-interactive batch script, which is executed
by the <code class="docutils literal"><span class="pre">ovitos</span></code> interpreter. Then we have to insert the <a class="reference internal" href="../modules/ovito_modifiers.html#ovito.modifiers.CalculateDisplacementsModifier" title="ovito.modifiers.CalculateDisplacementsModifier"><code class="xref py py-class docutils literal"><span class="pre">CalculateDisplacementsModifier</span></code></a> programmatically:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.io</span> <span class="k">import</span> <span class="n">import_file</span><span class="p">,</span> <span class="n">export_file</span>
<span class="kn">from</span> <span class="nn">ovito.modifiers</span> <span class="k">import</span> <span class="n">PythonScriptModifier</span><span class="p">,</span> <span class="n">CalculateDisplacementsModifier</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c1"># Load input data and create an ObjectNode with a data pipeline.</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">import_file</span><span class="p">(</span><span class="s2">&quot;simulation.dump&quot;</span><span class="p">,</span> <span class="n">multiple_frames</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># Calculate per-particle displacements with respect to initial simulation frame:</span>
<span class="n">dmod</span> <span class="o">=</span> <span class="n">CalculateDisplacementsModifier</span><span class="p">()</span>
<span class="n">dmod</span><span class="o">.</span><span class="n">reference</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;simulation.dump&quot;</span><span class="p">)</span>
<span class="n">node</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dmod</span><span class="p">)</span>

<span class="c1"># Define the custom modifier function:</span>
<span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>

    <span class="c1"># Access the per-particle displacement magnitudes computed by an existing </span>
    <span class="c1"># Displacement Vectors modifier that precedes this custom modifier in the </span>
    <span class="c1"># data pipeline:</span>
    <span class="n">displacement_magnitudes</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">particle_properties</span><span class="o">.</span><span class="n">displacement_magnitude</span><span class="o">.</span><span class="n">array</span>

    <span class="c1"># Compute MSD:</span>
    <span class="n">msd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">displacement_magnitudes</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">displacement_magnitudes</span><span class="p">)</span>

    <span class="c1"># Output MSD value as a global attribute: </span>
    <span class="n">output</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;MSD&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">msd</span> 

<span class="c1"># Insert custom modifier into the data pipeline.</span>
<span class="n">node</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PythonScriptModifier</span><span class="p">(</span><span class="n">function</span> <span class="o">=</span> <span class="n">modify</span><span class="p">))</span>

<span class="c1"># Export calculated MSD value to a text file and let OVITO&#39;s data pipeline do the rest:</span>
<span class="n">export_file</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;msd_data.txt&quot;</span><span class="p">,</span> 
    <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;txt&quot;</span><span class="p">,</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Timestep&quot;</span><span class="p">,</span> <span class="s2">&quot;MSD&quot;</span><span class="p">],</span>
    <span class="n">multiple_frames</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="implementing-an-advanced-analysis-modifier">
<span id="example-order-parameter-calculation"></span><h2>Implementing an advanced analysis modifier<a class="headerlink" href="#implementing-an-advanced-analysis-modifier" title="Permalink to this headline">¶</a></h2>
<p>In the paper <a class="reference external" href="https://doi.org/10.1103/PhysRevLett.86.5530">[Phys. Rev. Lett. 86, 5530]</a> an order parameter is specified as a means
of labeling an atom in the simulation as belonging to either the liquid or solid fcc crystal phase. In the following we will
develop a custom analysis modifier for OVITO, which calculates this per-atom order parameter.</p>
<p>The order parameter is defined as follows (see the paper for details): For any of the 12 nearest neighbors of a given atom one can compute the distance the neighbor
makes from the ideal fcc positions of the crystal in the given orientation (denoted by vector <strong>r</strong><sub>fcc</sub>). The sum of the distances over the 12 neighbors,
phi = 1/12*sum(| <strong>r</strong><sub>i</sub> - <strong>r</strong><sub>fcc</sub> |), acts as an &#8220;order parameter&#8221; for the central atom.</p>
<p>Calculating this parameter involves finding the 12 nearest neighbors of each atom and, for each of these neighbors, determining the
closest ideal lattice vector. To find the neighbors, OVITO provides the <a class="reference internal" href="../modules/ovito_data.html#ovito.data.NearestNeighborFinder" title="ovito.data.NearestNeighborFinder"><code class="xref py py-class docutils literal"><span class="pre">NearestNeighborFinder</span></code></a> utility class.
It directly provides the vectors from the central atom to its nearest neighbors.</p>
<p>Let us start by defining some inputs for the order parameter calculation at the global scope:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.data</span> <span class="k">import</span> <span class="n">NearestNeighborFinder</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># The lattice constant of the FCC crystal:</span>
<span class="n">lattice_parameter</span> <span class="o">=</span> <span class="mf">3.6</span> 

<span class="c1"># The list of &lt;110&gt; ideal neighbor vectors of the reference lattice (FCC):</span>
<span class="n">reference_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span>
    <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
<span class="p">])</span>
<span class="c1"># Rescale ideal lattice vectors with lattice constant.</span>
<span class="n">reference_vectors</span> <span class="o">*=</span> <span class="n">lattice_parameter</span>

<span class="c1"># The number of neighbors to take into account per atom:</span>
<span class="n">num_neighbors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_vectors</span><span class="p">)</span>
</pre></div>
</div>
<p>The actual modifier function needs to create an output particle property, which will store the calculated
order parameter of each atom. Two nested loops run over all input atoms and their 12 nearest neighbors respectively.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>

    <span class="c1"># Show a text in the status bar:</span>
    <span class="k">yield</span> <span class="s2">&quot;Calculating order parameters&quot;</span>

    <span class="c1"># Create output property.</span>
    <span class="n">order_param</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">create_user_particle_property</span><span class="p">(</span>
        <span class="s2">&quot;Order Parameter&quot;</span><span class="p">,</span> <span class="s2">&quot;float&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">marray</span>
    
    <span class="c1"># Prepare neighbor lists.</span>
    <span class="n">neigh_finder</span> <span class="o">=</span> <span class="n">NearestNeighborFinder</span><span class="p">(</span><span class="n">num_neighbors</span><span class="p">,</span> <span class="nb">input</span><span class="p">)</span>
    
    <span class="c1"># Loop over all input particles</span>
    <span class="n">nparticles</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">number_of_particles</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nparticles</span><span class="p">):</span>
        
        <span class="c1"># Update progress percentage indicator</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="n">nparticles</span><span class="p">)</span>
        
        <span class="n">oparam</span> <span class="o">=</span> <span class="mf">0.0</span>	<span class="c1"># The order parameter of the current atom		</span>
        
        <span class="c1"># Loop over neighbors of current atom.</span>
        <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">neigh_finder</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            
            <span class="c1"># Compute squared deviation of neighbor vector from every </span>
            <span class="c1"># reference vector.</span>
            <span class="n">squared_deviations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="n">reference_vectors</span> <span class="o">-</span> <span class="n">neigh</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            
            <span class="c1"># Sum up the contribution from the best-matching vector.</span>
            <span class="n">oparam</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">squared_deviations</span><span class="p">)</span>
            
        <span class="c1"># Store result in output particle property.</span>
        <span class="n">order_param</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">oparam</span> <span class="o">/</span> <span class="n">num_neighbors</span>		
</pre></div>
</div>
<p>Note that the <code class="docutils literal"><span class="pre">yield</span></code> statements in the modifier function above are only needed to support progress feedback in the
graphical version of OVITO and to give the pipeline system the possibility to interrupt the long-running calculation when needed.</p>
</div>
<div class="section" id="creating-particles-and-bonds-programmatically">
<span id="example-creating-particles-programmatically"></span><h2>Creating particles and bonds programmatically<a class="headerlink" href="#creating-particles-and-bonds-programmatically" title="Permalink to this headline">¶</a></h2>
<p>The following script demonstrates how to create particles, a simulation cell, and bonds on the fly
without loading an external simulation file. This approach can be used to implement custom data importers
or dynamically generate atomic structures, which can then be further processed with OVITO or exported to a file.</p>
<p>The script creates different data objects and adds them to a new <a class="reference internal" href="../modules/ovito_data.html#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal"><span class="pre">DataCollection</span></code></a> instance.
Finally, an <a class="reference internal" href="../modules/ovito.html#ovito.ObjectNode" title="ovito.ObjectNode"><code class="xref py py-class docutils literal"><span class="pre">ObjectNode</span></code></a> is created and the <a class="reference internal" href="../modules/ovito_data.html#ovito.data.DataCollection" title="ovito.data.DataCollection"><code class="xref py py-class docutils literal"><span class="pre">DataCollection</span></code></a> is set as
its data source.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ovito</span>
<span class="kn">from</span> <span class="nn">ovito.data</span> <span class="k">import</span> <span class="o">*</span>

<span class="c1"># The number of particles we are going to create.</span>
<span class="n">num_particles</span> <span class="o">=</span> <span class="mi">3</span>

<span class="c1"># Create the particle position property.</span>
<span class="n">pos_prop</span> <span class="o">=</span> <span class="n">ParticleProperty</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">ParticleProperty</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">Position</span><span class="p">,</span> <span class="n">num_particles</span><span class="p">)</span>
<span class="n">pos_prop</span><span class="o">.</span><span class="n">marray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="n">pos_prop</span><span class="o">.</span><span class="n">marray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">7.0</span><span class="p">,</span> <span class="mf">4.2</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">)</span>
<span class="n">pos_prop</span><span class="o">.</span><span class="n">marray</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">9.2</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">)</span>

<span class="c1"># Create the particle type property and insert two atom types.</span>
<span class="n">type_prop</span> <span class="o">=</span> <span class="n">ParticleProperty</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">ParticleProperty</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">ParticleType</span><span class="p">,</span> <span class="n">num_particles</span><span class="p">)</span>
<span class="n">type_prop</span><span class="o">.</span><span class="n">type_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ParticleType</span><span class="p">(</span><span class="nb">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Cu&#39;</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)))</span>
<span class="n">type_prop</span><span class="o">.</span><span class="n">type_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ParticleType</span><span class="p">(</span><span class="nb">id</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)))</span>
<span class="n">type_prop</span><span class="o">.</span><span class="n">marray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># First atom is Cu</span>
<span class="n">type_prop</span><span class="o">.</span><span class="n">marray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Second atom is Ni</span>
<span class="n">type_prop</span><span class="o">.</span><span class="n">marray</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Third atom is Ni</span>

<span class="c1"># Create a user-defined particle property.</span>
<span class="n">my_prop</span> <span class="o">=</span> <span class="n">ParticleProperty</span><span class="o">.</span><span class="n">create_user</span><span class="p">(</span><span class="s1">&#39;My property&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="n">num_particles</span><span class="p">)</span>
<span class="n">my_prop</span><span class="o">.</span><span class="n">marray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.141</span>
<span class="n">my_prop</span><span class="o">.</span><span class="n">marray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">my_prop</span><span class="o">.</span><span class="n">marray</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="c1"># Create the simulation box.</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">SimulationCell</span><span class="p">()</span>
<span class="n">cell</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">cell</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">cell</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">line_width</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="c1"># Create bonds between particles.</span>
<span class="n">bonds</span> <span class="o">=</span> <span class="n">Bonds</span><span class="p">()</span>
<span class="n">bonds</span><span class="o">.</span><span class="n">add_full</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>    <span class="c1"># Creates two half bonds 0-&gt;1 and 1-&gt;0. </span>
<span class="n">bonds</span><span class="o">.</span><span class="n">add_full</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    <span class="c1"># Creates two half bonds 1-&gt;2 and 2-&gt;1.</span>
<span class="n">bonds</span><span class="o">.</span><span class="n">add_full</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>    <span class="c1"># Creates two half bonds 2-&gt;0 and 0-&gt;2.</span>

<span class="c1"># Create a data collection to hold the particle properties, bonds, and simulation cell.</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">DataCollection</span><span class="p">()</span>
<span class="n">data</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pos_prop</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">type_prop</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">my_prop</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span>

<span class="c1"># Create a node and insert it into the scene.</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">ovito</span><span class="o">.</span><span class="n">ObjectNode</span><span class="p">()</span>
<span class="n">node</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">data</span>
<span class="n">node</span><span class="o">.</span><span class="n">add_to_scene</span><span class="p">()</span>

<span class="c1"># Select the new node and adjust cameras of all viewports to show it.</span>
<span class="n">ovito</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">selected_node</span> <span class="o">=</span> <span class="n">node</span>
<span class="k">for</span> <span class="n">vp</span> <span class="ow">in</span> <span class="n">ovito</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">viewports</span><span class="p">:</span>
    <span class="n">vp</span><span class="o">.</span><span class="n">zoom_all</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="visualizing-local-lattice-orientations-using-particle-coloring">
<span id="example-visualize-local-lattice-orientation"></span><h2>Visualizing local lattice orientations using particle coloring<a class="headerlink" href="#visualizing-local-lattice-orientations-using-particle-coloring" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference external" href="../../particles.modifiers.polyhedral_template_matching.html">Polyhedredral Template Matching (PTM)</a> function of OVITO allows
computing the local lattice orientation for each atom in a (poly)crystal. The computed local orientations
are stored by the modifier as quaternions, i.e. as rotations within the fundamental zone, in the particle property named <code class="docutils literal"><span class="pre">Orientation</span></code>.
Each per-particle quaternion can be translated into an RGB color to visualize the local lattice orientation.
This can be achieved by inserting a <a class="reference internal" href="custom_modifiers.html#writing-custom-modifiers"><span class="std std-ref">custom Python modifier</span></a> into the pipeline which translates the output of the PTM modifier
into RGB values and stores them in the <code class="docutils literal"><span class="pre">Color</span></code> particle property.</p>
<p>In the graphical OVITO version, simply insert a new Python modifier and copy/paste the following script into the source code window:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ovito.data</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">quaternions_to_colors</span><span class="p">(</span><span class="n">qs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Takes a list of quaternions (Nx4 array) and returns a list of</span>
<span class="sd">        corresponding RGB colors (Nx3 array) &quot;&quot;&quot;</span>
 
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;qs must be a 2-dimensional array&quot;</span><span class="p">)</span>
 
    <span class="k">if</span> <span class="n">qs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;qs must be a n x 4 dimensional array&quot;</span><span class="p">)</span>
 
    <span class="c1"># Project quaternions into Rodrigues space: rs = (qs.X/qs.W, qs.Y/qs.W, qs.Z/qs.W)</span>
    <span class="c1"># Note that the qs.W may be zero for particles for which no lattice orientation</span>
    <span class="c1"># could be computed by the PTM modifier.</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">qs</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">qs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">qs</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">rs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">where</span><span class="o">=</span><span class="n">qs</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">qs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">qs</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">rs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">where</span><span class="o">=</span><span class="n">qs</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">qs</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">qs</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">rs</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">where</span><span class="o">=</span><span class="n">qs</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Compute vector lengths rr = norm(rs)</span>
    <span class="n">rr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">rr</span><span class="p">,</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">9</span><span class="p">)</span> <span class="c1"># hack</span>
 
    <span class="c1"># Normalize Rodrigues vectors.</span>
    <span class="n">rs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">rr</span>
    <span class="n">rs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">rr</span>
    <span class="n">rs</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">/=</span> <span class="n">rr</span>
 
    <span class="n">theta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">rr</span><span class="p">)</span>
    <span class="n">rs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">theta</span>
    <span class="n">rs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">theta</span>
    <span class="n">rs</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">theta</span>
    
    <span class="c1"># Normalize values.</span>
    <span class="n">rs</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">62.8</span><span class="p">)</span>
    <span class="n">rs</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">62.8</span><span class="p">)</span>
    <span class="n">rs</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">62.8</span><span class="p">)</span>
    <span class="n">rs</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">62.8</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">rs</span>
    
<span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; The custom modifier function &quot;&quot;&quot;</span>
    
    <span class="c1"># The input:</span>
    <span class="n">orientation_property</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">particle_properties</span><span class="o">.</span><span class="n">orientation</span><span class="o">.</span><span class="n">array</span>
    
    <span class="c1"># The output:</span>
    <span class="n">color_property</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">create_particle_property</span><span class="p">(</span><span class="n">ParticleProperty</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">Color</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="running.html">Running scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="file_io.html">File I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="modifiers.html">Modifiers</a></li>
<li class="toctree-l1"><a class="reference internal" href="particle_properties.html">Particle properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="rendering.html">Rendering</a></li>
<li class="toctree-l1"><a class="reference internal" href="custom_modifiers.html">Writing new modifiers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules/ovito.html"><code class="docutils literal"><span class="pre">ovito</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/ovito_anim.html"><code class="docutils literal"><span class="pre">ovito.anim</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/ovito_data.html"><code class="docutils literal"><span class="pre">ovito.data</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/ovito_io.html"><code class="docutils literal"><span class="pre">ovito.io</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/ovito_modifiers.html"><code class="docutils literal"><span class="pre">ovito.modifiers</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules/ovito_vis.html"><code class="docutils literal"><span class="pre">ovito.vis</span></code></a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../modules/ovito.html" title="ovito"
             >next</a> |</li>
        <li class="right" >
          <a href="custom_modifiers.html" title="Writing new modifiers"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">OVITO 2.9.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Alexander Stukowski.
    </div>
  </body>
</html>